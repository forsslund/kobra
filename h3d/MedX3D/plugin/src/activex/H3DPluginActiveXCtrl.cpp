//////////////////////////////////////////////////////////////////////////////
//    Copyright 2004-2019, SenseGraphics AB
//
//    This file is part of MedX3D.
//
//    MedX3D is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 2 of the License, or
//    (at your option) any later version.
//
//    MedX3D is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with MedX3D; if not, write to the Free Software
//    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//    A commercial license is also available. Please contact us at 
//    www.sensegraphics.com for more information.
//
//
/// \file H3DPluginActiveXCtrl.h
/// \brief CPP file for CH3DPluginActiveXCtrl. File generated by Visual
/// Studio templates and then modified. Handle messages from window.
///
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "H3DPluginActiveX.h"
#include "H3DPluginActiveXCtrl.h"
#include "../keys.h"
#include <cassert>
#include <shlwapi.h>
#include <wininet.h>
#ifdef USE_TIMER
const int kTimerEvent = 1;
#endif

/// Apparently stdafx has LEFT_BUTTON defined.
/// Stupid. windows.
#ifdef WIN32
#undef LEFT_BUTTON
#undef MIDDLE_BUTTON
#undef RIGHT_BUTTON
#endif
#include <H3D/MouseSensor.h>

/**
 * Local globals
 */

/** 
 * Uses hooking to get arrow keys since they are considered special by windows
 * This hook needs to be global (for compatibility with windows version < 2000)
 */
HHOOK hook = NULL;
/**
 * Hook function needs to know how to access the controlclass
 */
CH3DPluginActiveXCtrl *controlclass = NULL;

/**
 * Hook function for keyboard input used by the activex ctrl
 */
LRESULT CALLBACK KeyboardProc( int code, WPARAM wparam, LPARAM lparam ) {
  // Check if we should handle message and assert controlclass is set
  if( code >= 0 && controlclass != NULL) {
    // Handle keycode, should check for HC_ACTION / HC_NOREMOVE?
    if( code == HC_ACTION ) {
      UINT repeatcount = lparam & 0xFFFF; // Repeatcount stored in bits 0-15
      // The bits in lparam except the repeatcount
      UINT flags = lparam & 0xFFFF0000;
      // We need the transition state so we know which function to call
      // (onkeyup or onkeydown)
      bool released = ((lparam & 0x80000000) != 0);
      char buf[200];
      sprintf( buf, "Repeatcount: %d\nCode: %x\n, Flags: %x\n, Released: %d\n",
               repeatcount, code, flags, released );
      switch( wparam ) {
        case VK_UP:
        case VK_DOWN:
        case VK_LEFT:
        case VK_RIGHT:
          if( released ) {
            controlclass->OnKeyUp( wparam, repeatcount, flags );
          } else {
            controlclass->OnKeyDown( wparam, repeatcount, flags );
          }
      }
    }
  }

  return CallNextHookEx(hook, code, wparam, lparam);
}

/**
 * ActiveX message map
 */
BEGIN_MESSAGE_MAP(CH3DPluginActiveXCtrl, COleControl)
  ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
  ON_WM_CREATE()
  ON_WM_DESTROY()
#ifdef USE_TIMER
  ON_WM_TIMER()
#endif
  ON_WM_CONTEXTMENU()
  ON_WM_LBUTTONDOWN()
  ON_WM_MOUSEMOVE()
  ON_WM_KEYDOWN()
  ON_WM_KEYUP()
  ON_WM_LBUTTONUP()
  ON_WM_MBUTTONDOWN()
  ON_WM_MBUTTONUP()
  ON_WM_RBUTTONDOWN()
  ON_WM_RBUTTONUP()
  ON_WM_MOUSEWHEEL()
  ON_COMMAND_RANGE( ID_NAVIGATION_MENU,
                    ID_NAVIGATION_MENU_MAX,
                    OnNavigationMenu )
  ON_COMMAND_RANGE( ID_VIEWPOINT_MENU, ID_VIEWPOINT_MENU_MAX, OnViewpointMenu )
  ON_WM_SIZE()
END_MESSAGE_MAP()

/**
 * ActiveX Interface IDs (COM objects)
 */
// {B680B237-D5CF-408e-9FCC-6074480C915F}
const IID BASED_CODE IID_DH3DPluginActiveX = 
{ 0xb680b237, 0xd5cf, 0x408e,
  { 0x9f, 0xcc, 0x60, 0x74, 0x48, 0xc, 0x91, 0x5f } };

// {82EF0BF9-EFE5-4ecb-8BE5-70B428E490A0}
const IID BASED_CODE IID_DH3DPluginActiveXEvents =
{ 0x82ef0bf9, 0xefe5, 0x4ecb,
  { 0x8b, 0xe5, 0x70, 0xb4, 0x28, 0xe4, 0x90, 0xa0 } };


list< CH3DPluginActiveXCtrl * > CH3DPluginActiveXCtrl::paxct_instances;
/**
 * CH3DPluginActiveXCtrl class methods
 */
CH3DPluginActiveXCtrl::CH3DPluginActiveXCtrl():
is_control_class( false ),
scene_root_removed( false )
{
  InitializeIIDs(&IID_DH3DPluginActiveX, &IID_DH3DPluginActiveXEvents);
  m_hasSrc = false;
#ifdef PRINT_ERR_FILE
  cerr << "new CH3DPluginActiveXCtrl created " << this << endl;
#endif
  paxct_instances.push_back( this );
}


CH3DPluginActiveXCtrl::~CH3DPluginActiveXCtrl()
{
#ifdef PRINT_ERR_FILE
  cerr << "CH3DPluginActiveXCtrl " << this << " destroyed." << endl;
#endif
  paxct_instances.remove( this );
}

void CH3DPluginActiveXCtrl::render()
{
  if( !m_hWnd )
    return;

  if( m_InstanceThread.IsStarted() )
  {
    m_InstanceThread.Update();
    return;
  }


  if( !m_InstanceThread.IsStarted() && m_hasSrc )
  {
    InvalidateControl();
    /**
     * 'Auto' activation of control
     */
    OnActivateInPlace( TRUE, NULL );
    InternalSetReadyState( READYSTATE_COMPLETE );

    int control_width, control_height;
    GetControlSize( &control_width, &control_height );
#ifdef PRINT_ERR_FILE
    cerr << "window handle " << *this << endl;
#endif
    if( !m_InstanceThread.initializedWindow() )
      m_InstanceThread.initWindow( *this, control_width, control_height );
    if( !m_InstanceThread.Start( std::string(m_src) ) ) {
      //std::string message = "Failed to read file: " + m_src + " correctly.";
      m_hasSrc = false; // Reset the 'invalid' source to nonexistent.
      //::MessageBox( HWND_DESKTOP, message.c_str(), "Error", MB_ICONERROR );
    }
    return;
  }

  InvalidateControl();
}

/**
 * Read input from the HTML source code
 * And work some magic with the OLE interfaces to access the URL
 * Also adds an ugly function to help with cleanup
 */

#define COMRELEASE(ptr)\
  if (ptr != NULL) {\
    ptr->Release();\
    ptr = NULL;\
  }

void CH3DPluginActiveXCtrl::DoPropExchange(CPropExchange* pPX)
{
  ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
  COleControl::DoPropExchange(pPX);

  IOleClientSite *cs = GetClientSite();
  IServiceProvider *isp, *topmost_isp = NULL;
  
  HRESULT hres = cs->QueryInterface( IID_IServiceProvider,
                                     reinterpret_cast<void **>(&isp) );
  if( FAILED(hres) ) {
    ::MessageBox( HWND_DESKTOP,
      "Internal error occured: Failed to get IServiceProvider. Call support.",
      "Error", MB_ICONERROR );
    COMRELEASE( isp );
    return;
  }

  hres = isp->QueryService( SID_STopLevelBrowser, IID_IServiceProvider,
                            reinterpret_cast<void **>(&topmost_isp) );
  if( FAILED(hres) ) {
    ::MessageBox( HWND_DESKTOP,
      "Internal error: Failed to get topmost IServiceProvider. Call support.",
      "Error", MB_ICONERROR );
    COMRELEASE( isp );
    return;
  }

  IWebBrowser2 *browser = NULL;
  hres = topmost_isp->QueryService( SID_SWebBrowserApp, IID_IWebBrowser2,
                                    reinterpret_cast<void **>(&browser) );
  if( FAILED(hres) ) {
    ::MessageBox(HWND_DESKTOP,
      "Internal error: Failed to get IWebBrowser2. Call support.",
      "Error", MB_ICONERROR);
    COMRELEASE(isp);
    COMRELEASE(topmost_isp);
    return;
  }


  BSTR locationUrl;
  hres = browser->get_LocationURL(&locationUrl);
  if( FAILED( hres ) ) {
    ::MessageBox( HWND_DESKTOP, "Internal error: Failed to get location URL",
                  "Error", MB_ICONERROR);
    COMRELEASE(isp);
    COMRELEASE(topmost_isp);
    COMRELEASE(browser);
    return;
  }
  
  COMRELEASE(isp);
  COMRELEASE(topmost_isp);
  COMRELEASE(browser);

  // We will not know if were called by an object tag or by an embed tag...
  // and we want to handle both "src" and "SRC" param names
  // Check "src" first
  if( !PX_String( pPX, "src", m_src ) ) {
    if( !PX_String( pPX, "SRC", m_src ) ) {
      // No file source found that we can use
      ::MessageBox(HWND_DESKTOP,
        "Unable to locate src attribute. Required to load x3d-file.",
        "Error", MB_ICONERROR);
    }
  } 
  
  // Make sure we have something
  if( m_src.Compare("") == 0 ) {
    ::MessageBox( HWND_DESKTOP, "src attribute found but contains no filename.",
                  "Error", MB_ICONERROR);
  } else {
    // Ok, check if path set was absolute
    if( m_src.Find( "http" ) != 0 && 
      m_src.Find( "ftp" )  != 0  &&
      m_src.Find( "file")  != 0 ) {
      // url not absolute. Construct it from the document url (locationUrl) and
      // the relative path (m_src).
      // 1. Get the base path from the locationUrl
      CString url = CString(locationUrl);
      int pos = url.ReverseFind('/');
      if( pos == -1 ) {
        ::MessageBox( HWND_DESKTOP,
          "Internal error: Base path is malformed, cannot continue.",
          "Error", MB_ICONERROR);
        return;
      }
      CString baseUrl = url.Left( pos + 1 );
      // 2. Combine the base url with relative path in m_src

      char combined[INTERNET_MAX_URL_LENGTH];
      DWORD size = INTERNET_MAX_URL_LENGTH;
      hres = UrlCombine( baseUrl.GetBuffer(), m_src.GetBuffer(), combined,
                         &size, 0 );
      if( FAILED( hres ) ) {
        // This should never occur...but report it
        ::MessageBox( HWND_DESKTOP, "Internal error: UrlCombine failed.",
                      "Error", MB_ICONERROR);
        return;
      } else {
        m_src = CString( combined );
        m_hasSrc = true;
      }
    } else {
      m_hasSrc = true;
    }
  }

  InternalSetReadyState( READYSTATE_INTERACTIVE );
  InvalidateControl();
}

void CH3DPluginActiveXCtrl::OnResetState()
{
  COleControl::OnResetState();
}

#ifdef USE_TIMER
void CH3DPluginActiveXCtrl::OnTimer( UINT_PTR event )
{
  if( is_control_class ) {
    render();
  }
  else {
    if( !scene_root_removed ) {
      scene_root_removed = true;
      m_InstanceThread.resetRoot();
    }
  }
}
#endif

int CH3DPluginActiveXCtrl::OnCreate( LPCREATESTRUCT lpCreateStruct )
{
#ifdef PRINT_ERR_FILE
  cerr  << "CH3DPluginActiveXCtrl::OnCreate " << this << endl;
#endif
  if( COleControl::OnCreate(lpCreateStruct) == -1 )
    return -1;

    // Setup hook system
  controlclass = this;
  controlclass->setControlClass( true );
  if( !hook )
    hook = SetWindowsHookEx( WH_KEYBOARD, (HOOKPROC) &KeyboardProc, NULL,
                             GetCurrentThreadId() );
  if( hook == NULL ) {
    // Ooops: Internal error, should never ever occur
  }


#ifdef USE_TIMER
  SetTimer( kTimerEvent, 1000/PlayerFPS, NULL );
#endif

  // automatically UI-activate the control
  OnActivateInPlace( TRUE, NULL );
  return 0;
}

void CH3DPluginActiveXCtrl::OnDestroy()
{
#ifdef PRINT_ERR_FILE
  cerr << "OnDestroy " << this << endl;
#endif
#ifdef USE_TIMER
  KillTimer( kTimerEvent );
#endif
  
  if( hook ) {
    UnhookWindowsHookEx(hook);
  }

  m_InstanceThread.Stop();
}

/* point contains SCREEN coordinates */
void CH3DPluginActiveXCtrl::OnContextMenu(CWnd* pWnd, CPoint point )
{
  if( is_control_class ) {
    CMenu popup;
    CMenu navMenu;
    CMenu vpMenu;

    popup.CreatePopupMenu();
    navMenu.CreatePopupMenu();
    vpMenu.CreatePopupMenu();

    // ---------- Build navigation menu ----------
    H3DPluginInstance::MenuList *navList =
      m_InstanceThread.getNavigationMenuList();
    if( navList ) {
      vector<string>* items = navList->getItems();

      // Build menu from list
      int i = 0;
      int checkedPos = 0;
      string checked = navList->getChecked();
      for( vector<string>::iterator it = items->begin();
           it != items->end(); ++it ) {
        navMenu.AppendMenu( MF_STRING | MF_ENABLED, ID_NAVIGATION_MENU + i,
                            (*it).c_str() );
        if( (*it) == checked ) {
          checkedPos = i;
        }
        ++i;
      }

      navMenu.CheckMenuRadioItem( ID_NAVIGATION_MENU,
                                  ID_NAVIGATION_MENU+items->size() - 1,
                                  ID_NAVIGATION_MENU+checkedPos, MF_BYCOMMAND);
      if( !navList->isCheckedEnabled() ) {
        navMenu.EnableMenuItem( ID_NAVIGATION_MENU+checkedPos,
                                MF_BYCOMMAND | MF_GRAYED );
      }
    }

    // ---------- x ----------

    // ---------- Build viewpoint menu ----------
    H3DPluginInstance::MenuList *vpList =
      m_InstanceThread.getViewpointMenuList();
    if( vpList ) {
      vector<string>* items = vpList->getItems();

      int i = 0;
      int checkedPos = 0;
      string checked = vpList->getChecked();
      for( vector<string>::iterator it = items->begin();
           it != items->end(); ++it ) {
        vpMenu.AppendMenu( MF_STRING | MF_ENABLED, ID_VIEWPOINT_MENU + i,
                           (*it).c_str() );
        if( (*it) == checked ) {
          checkedPos = i;
        }
        ++i;
      }

      vpMenu.CheckMenuRadioItem( ID_VIEWPOINT_MENU,
                                 ID_VIEWPOINT_MENU + items->size() - 1,
                                 ID_VIEWPOINT_MENU + checkedPos, MF_BYCOMMAND);
      if( !vpList->isCheckedEnabled() ) {
        vpMenu.EnableMenuItem( ID_VIEWPOINT_MENU+checkedPos,
                               MF_BYCOMMAND | MF_GRAYED );
      }
    }

    // ---------- x ----------

    // Then display it

    popup.AppendMenu( MF_POPUP, (UINT) navMenu.GetSafeHmenu(), "Navigation" );
    popup.AppendMenu( MF_POPUP, (UINT) vpMenu.GetSafeHmenu(), "Viewpoint" );

    popup.TrackPopupMenu( 0, point.x, point.y, pWnd, NULL );
  }
}

void CH3DPluginActiveXCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
  m_InstanceThread.onLeftMouseButtonDown();
  COleControl::OnLButtonDown(nFlags, point);
}

void CH3DPluginActiveXCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
  if( m_InstanceThread.IsStarted() )
    m_InstanceThread.onMouseMotion( point.x, point.y );
  COleControl::OnMouseMove(nFlags, point);
}

void CH3DPluginActiveXCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
  int key = getKeyFromKeycode( nChar );
  if( key > 0 ) {
    m_InstanceThread.onKeyDown( key, true );
  } else {
    m_InstanceThread.onKeyDown( nChar, false );
  }
}

void CH3DPluginActiveXCtrl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
  int key = getKeyFromKeycode( nChar );
  if( key > 0 ) {
    m_InstanceThread.onKeyUp( key, true );
  } else {
    m_InstanceThread.onKeyUp( nChar, false );
  }
}

void CH3DPluginActiveXCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
  m_InstanceThread.onLeftMouseButtonUp();
  COleControl::OnLButtonUp(nFlags, point);
}

void CH3DPluginActiveXCtrl::OnMButtonDown(UINT nFlags, CPoint point)
{
  m_InstanceThread.onMiddleMouseButtonDown();
  COleControl::OnMButtonDown(nFlags, point);
}

void CH3DPluginActiveXCtrl::OnMButtonUp(UINT nFlags, CPoint point)
{
  m_InstanceThread.onMiddleMouseButtonUp();
  COleControl::OnMButtonUp(nFlags, point);
}

void CH3DPluginActiveXCtrl::OnRButtonDown(UINT nFlags, CPoint point)
{
  m_InstanceThread.onRightMouseButtonDown();
  COleControl::OnRButtonDown(nFlags, point);
}

void CH3DPluginActiveXCtrl::OnRButtonUp(UINT nFlags, CPoint point)
{
  m_InstanceThread.onRightMouseButtonUp();
  COleControl::OnRButtonUp(nFlags, point);
}

BOOL CH3DPluginActiveXCtrl::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)
{
  m_InstanceThread.onMouseWheel( zDelta > 0 ?
                                 MouseSensor::FROM : 
                                 MouseSensor::TOWARDS );
  return COleControl::OnMouseWheel(nFlags, zDelta, pt);
}


void CH3DPluginActiveXCtrl::OnNavigationMenu( UINT nID )
{
  /* Locate item that corresponds to menu selection */
  vector<string> *items = m_InstanceThread.getNavigationMenuList()->getItems();
  int i = 0;
  vector<string>::iterator it;
  for( it = items->begin(); it != items->end(); ++it ) {
    if( ID_NAVIGATION_MENU + i == nID ) {
      break;
    }
    ++i;
  }

  m_InstanceThread.onMenuCommand( H3DPluginInstance::ID_NAVIGATION_MENU, (*it) );
}

void CH3DPluginActiveXCtrl::OnViewpointMenu( UINT nID )
{
  /* Locate item that corresponds to menu selection */
  vector<string> *items = m_InstanceThread.getViewpointMenuList()->getItems();
  int i = 0;
  vector<string>::iterator it;
  for( it = items->begin(); it != items->end(); ++it ) {
    if( ID_VIEWPOINT_MENU + i == nID ) {
      break;
    }
    ++i;
  }

  m_InstanceThread.onMenuCommand( H3DPluginInstance::ID_VIEWPOINT_MENU, (*it) );
}

DWORD CH3DPluginActiveXCtrl::GetControlFlags()
{
  // The control will not be redrawn when making the transition
  // between the active and inactivate state.
  return (COleControl::GetControlFlags() | noFlickerActivate);
}

void CH3DPluginActiveXCtrl::setControlClass( bool _is_control_class ) {
  if( _is_control_class ) {
    for( list< CH3DPluginActiveXCtrl * >::iterator i = paxct_instances.begin();
         i != paxct_instances.end(); ++i ) {
      if( (*i) == this ) {
        (*i)->is_control_class = true;
      }
      else {
        (*i)->is_control_class = false;
      }
    }
  }
  else {
    is_control_class = false;
  }
}

void CH3DPluginActiveXCtrl::OnSize( UINT nType, int cx, int cy ) {
  controlclass->setSizeOfContainedWindow( cx, cy );
  COleControl::OnSize( nType, cx, cy );
}

void CH3DPluginActiveXCtrl::setSizeOfContainedWindow( int cx, int cy ) {
  m_InstanceThread.setPluginWindowSize( cx, cy );
}
