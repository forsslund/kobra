//////////////////////////////////////////////////////////////////////////////
//
/// MCWithRange.h is a modified version of MarchingCubes.h in MedX3D by
/// Copyright 2004-2008, SenseGraphics AB
///
/// Modified by: Sudanthi Wijewickrema
/// 		Dept. of Otolaryngology
/// 		University of Melbourne
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __MCWithRange_H__
#define __MCWithRange_H__

#include <H3D/X3DGeometryNode.h>
#include <H3D/X3DTexture3DNode.h>
#include <H3D/SFInt32.h>
#include <H3D/MFString.h>
#include <H3D/MFVec3f.h>
#include <H3D/Scene.h>
#include <H3D/TextureProperties.h>
#include "MaterialSegmentationModel.h"
#include "SmoothingMask.h"
#include <H3D/Material.h>
#include <H3D/MFColor.h>
#include <H3D/Color.h>
#include "DataBounds.h"

#define GRADIENTS_ON_THE_FLY

using namespace H3D;

typedef unsigned int uint;

namespace FS {

/// \ingroup Geometries
/// \class MarchingCubes
/// \brief The MarchingCubes geometry is a node for generating an 
/// triangle-mesh iso-surface from a volume data set and an iso-value.
///
/// This node currently only works for LUMINANCE textures as
/// input to the voxels field. MarchingCubes will not work for textures in
/// which any of the texture dimensions contains less than 2 pixels.
class MCWithRange: public X3DGeometryNode {
public:

	/// The OctTreeNode class defines a tree structure for voxel space 
	/// partitioning where each node is has 8 children dividing the 
	/// space it contains.
	/// Each node contains information about which voxels it contains,
	/// what triangles has been generated for the node( if leaf), etc.
	/// The structure is used in order to only regenerate local triangles
	/// when doing dynamic updates to the volume data instead of having to 
	/// regenerate triangles for the entire dataset.
	struct OctTreeNode: public RefCountedClass {

	public:
		/// Constructor.
		OctTreeNode() :
				cache(0), value_min(0), // todo: proper values
				value_max(1000), parent(NULL), next(NULL) {
			for (int i = 0; i < 8; i++)
				children[i] = NULL;
		}

		/// Destructor
		~OctTreeNode();

		/// Returns true if this node is a leaf node.
		inline bool isLeaf() {
			return children[0] == NULL;
		}

		/// The OpenGL display list used for rendering the triangles generated by
		/// the marching cubes algorithm for this node. 0 if no such display list
		/// has been generated.
		GLuint cache;

		/// The minimum voxel value of any voxel within this node.
		H3DFloat value_min;

		/// The maximum voxel value of any voxel within this node.
		H3DFloat value_max;

		/// The parent of the node.
		OctTreeNode *parent;

		/// If this is a leaf node next points to the next node in the leaf.
		OctTreeNode *next;

		/// The children nodes of the OctTreeNode.
		OctTreeNode *children[8];
		/// The minimum voxel index value in the x-direction of this node.
		uint x_min;
		/// The maximum voxel index value in the x-direction of this node.
		uint x_max;
		/// The minimum voxel index value in the y-direction of this node.
		uint y_min;
		/// The maximum voxel index value in the y-direction of this node.
		uint y_max;
		/// The minimum voxel index value in the z-direction of this node.
		uint z_min;
		/// The maximum voxel index value in the z-direction of this node.
		uint z_max;

		/// The vertices generated by the marching cubes algorithm for this node.
		/// Empty if not leaf node.
		vector<Vec3f> vvertex;

		/// The normals generated by the marching cubes algorithm for this node.
		/// Empty if not leaf node.
		vector<Vec3f> vnormal;

		vector<Vec4f> vcolour;

		/// Render this node using OpenGL. If a leaf node a display list will
		/// be generated to render the triangles for this node the next time.
		void render();

		/// Subdivide the current node depth number of times. All previous
		/// children will be removed.
		void subdivide(int depth);
	};

	/// The SFOctTree class is a field class that updates its internal 
	/// oct tree and marching cubes triangles according to changes in
	/// volume data and iso value.
	///
	/// routes_in[0] is the isovalue   (SFFloat)
	/// routes_in[1] is the voxel data (SFTexture3DNode)
	class SFOctTree: public RefCountSField<OctTreeNode> {
	public:
		/// Constructor.
      SFOctTree() : 
        data_matrix( 0 ),
        unsmoothedDataMatrix( NULL ),
        textureMatrix( NULL ),
        hilightMatrix( NULL ),
        cryoColourMatrix( NULL ),
        defaultHilightColour (RGB(0.5, 1.0, 0.5)),
        x_points( 0 ),
        y_points( 0 ),
        z_points( 0 ),
        function_count( 0 ),
        update_thread( new PeriodicThread ){
    	update_thread->setThreadName( "MarchingCubes update thread" );
	   }

		~SFOctTree();

		/// Structure for transferring data to separate thread to calculate
		/// new triangles if thread mode is used.
		struct UpdateData {
			float iso_value;
			uint x_min, y_min, z_min, x_max, y_max, z_max;
			AutoRef<MCWithRange> mc;
			OctTreeNode *oct_tree_leaf;
		};

		/// Structure for transferring triangles back when new triangles
		/// have been calculated in separate thread.
		struct TransferData {
			auto_ptr<vector<Vec3f> > vertices;
			auto_ptr<vector<Vec3f> > normals;
			auto_ptr<vector<Vec4f> > colours;
			AutoRef<MCWithRange> mc;
			OctTreeNode *oct_tree_leaf;
		};

		/// Update the oct tree value_min and value_max values according
		/// to the current values of the voxel values in the data_matrix
		/// member.
		void updateMinMaxValues(OctTreeNode *t);

		/// Recalculates all the triangles in the oct tree using the 
		/// marching cubes algorithm using the voxel values in the data_matrix
		/// member.
		/// 
		/// \param tree The oct tree which we should update with new triangle
		/// info.
		/// \param iso_value The iso-value of the iso-surface of which to
		/// extract triangles.
		/// \param update_data If the update_data paramater is given the 
		/// function will not update the triangle data directly. Instead it will
		/// collect a set of functions and parameters that have to be called in
		/// order for the update to occur. This can be used to e.g. call these
		/// functions in different threads in order to speed up computation.
		void updateMCTriangles(OctTreeNode *tree, H3DFloat iso_value,
				vector<pair<PeriodicThread::CallbackFunc, UpdateData *> > *update_data =
						NULL);

		/// Recalculates all the triangles within a subvolume in the oct tree
		/// using the marching cubes algorithm using the voxel values in the
		/// data_matrix member.
		/// 
		/// \param tree The oct tree which we should update with new triangle
		/// info.
		/// \param iso_value The iso-value of the iso-surface of which to extract
		/// triangles.
		/// \param volume_min_x The voxel with the lowest index in x direction of
		/// the subvolume.
		/// \param volume_max_x The voxel with the highest index in x direction
		/// of the subvolume.
		/// \param volume_min_y The voxel with the lowest index in y direction of
		/// the subvolume.
		/// \param volume_max_y The voxel with the highest index in y direction
		/// of the subvolume.
		/// \param volume_min_z The voxel with the lowest index in z direction of
		/// the subvolume.
		/// \param volume_max_z The voxel with the highest index in z direction
		/// of the subvolume.
		/// \param update_data If the update_data paramater is given the function
		/// will not update the triangle data directly. Instead it will collect a
		/// set of functions and parameters that have to be called in order for
		/// the update to occur. This can be used to e.g. call these functions in
		/// different threads in order to speed up computation.
        void updateMCTrianglesInVolume(  OctTreeNode *tree,
                                       H3DFloat iso_value,  
                                       uint volume_min_x,
                                       uint volume_min_y,
                                       uint volume_min_z,
                                       uint volume_max_x,
                                       uint volume_max_y,
                                       uint volume_max_z,
                                    vector< pair< PeriodicThread::CallbackFunc,
                                       UpdateData * > > *update_data = NULL );

		/// This function generates triangles using the marching cubes algorithm 
		/// for a specified subvolume of data.
		/// 
		/// \param iso_value The iso-value of the iso-surface of which to extract
		/// triangles.
		/// \param x_min The voxel with the lowest index in x direction of the
		/// subvolume.
		/// \param x_max The voxel with the highest index in x direction of the
		/// subvolume.
		/// \param y_min The voxel with the lowest index in y direction of the
		/// subvolume.
		/// \param y_max The voxel with the highest index in y direction of the
		/// subvolume.
		/// \param z_min The voxel with the lowest index in z direction of the
		/// subvolume.
		/// \param z_max The voxel with the highest index in z direction of the
		/// subvolume.
		/// \param vertices Generated vertices of the triangles.
		/// \param normals Generated normals of the triangles.
        void vMarchingCubes( H3DFloat iso_value, 
                           uint x_min, uint x_max, 
                           uint y_min, uint y_max, 
                           uint z_min, uint z_max, 
                           vector< Vec3f > &vertices,
                           vector< Vec3f > &normals,
                           vector< Vec4f > &colours);

		/// Create the local copy of the data that is maintained for both speed
		/// and for thread consistency when using different threads. It will
		/// update the data_matrix, voxel_size and ?_points members.
		void buildDataMatrix(Image *i, TextureProperties *tp);

		// Create matrix of intensity values
		void buildTextureMatrix(Image *textureImage);

		// Create matrix of hilight values
		void buildHilightMatrix(Image *hilightImage);

		// Create matrix of colour values
		void buildCryoColourMatrix(Image *cryoColourImage);

		// Set colours that represent each unique value in hilightMatrix 
		void setHilightColours(vector<RGB> hilightCols);

		/// Update the local copy of the data that is maintained for both speed
		/// and for thread consistency when using different threads. It will
		/// update the data_matrix, voxel_size and ?_points members in the
		/// subvolume defined.
        void updateDataMatrix( Image *i,
                             uint volume_min_x,
                             uint volume_min_y,
                             uint volume_min_z,
                             uint volume_max_x,
                             uint volume_max_y,
                             uint volume_max_z,
                             TextureProperties *tp);

		/// Update the gradients in the subvolume specified by the function
		/// parameters. Updates will be done directly in the gradients parameter
		/// and it is assumed that the vector is of the correct size before a
		/// call to this function.
        virtual  void updateGradients(uint x_min, uint x_max,
                                    uint y_min, uint y_max,
                                    uint z_min, uint z_max,
                                    vector< Vec3f > &gradients );

		/// Returns the value of the voxel at the specified index.
        inline H3DFloat getVoxelValue( uint x, 
                                     uint y, 
                                     uint z ) {
			//MarchingCubes *mc = static_cast< MarchingCubes * >( getOwner() );
			//return mc->voxels->getValue()->
			//         image->getValue()->getPixel( x, y, z ).r;
			return data_matrix[(z * y_points + y) * x_points + x];
		}

		/// Returns the value of the texture voxel at the specified index.
		H3DFloat getTextureValue(uint x, uint y, uint z);

		/// Returns the value of the highlight voxel at the specified index.
		uint getHilightValue(uint x, uint y, uint z);

		/// Returns the value of the cryoColour voxel at the specified index.
		RGB getCryoColourValue(uint x, uint y, uint z);

		/// Returns the gradient of the voxel at the specified index.
		inline Vec3f getGradient(uint x, uint y, uint z) {
#ifdef GRADIENTS_ON_THE_FLY
			//int index = ( z*y_points + y ) * x_points +x;
			Vec3f gradient;

			if (x == 0) {
				gradient.x = (getVoxelValue(x + 1, y, z)
						- getVoxelValue(x, y, z)) / voxel_size.x;
			} else if (x == x_points - 1) {
				gradient.x = (getVoxelValue(x, y, z)
						- getVoxelValue(x - 1, y, z)) / voxel_size.x;
			} else {
				gradient.x = (getVoxelValue(x + 1, y, z)
						- getVoxelValue(x - 1, y, z)) / (2 * voxel_size.x);
			}

			if (y == 0) {
				gradient.y = (getVoxelValue(x, y + 1, z)
						- getVoxelValue(x, y, z)) / voxel_size.y;
			} else if (y == y_points - 1) {
				gradient.y = (getVoxelValue(x, y, z)
						- getVoxelValue(x, y - 1, z)) / voxel_size.y;
			} else {
				gradient.y = (getVoxelValue(x, y + 1, z)
						- getVoxelValue(x, y - 1, z)) / (2 * voxel_size.y);
			}

			if (z == 0) {
				gradient.z = (getVoxelValue(x, y, z + 1)
						- getVoxelValue(x, y, z)) / voxel_size.z;
			} else if (z == z_points - 1) {
				gradient.z = (getVoxelValue(x, y, z)
						- getVoxelValue(x, y, z - 1)) / voxel_size.z;
			} else {
				gradient.z = (getVoxelValue(x, y, z + 1)
						- getVoxelValue(x, y, z - 1)) / (2 * voxel_size.z);
			}

			return gradient;
#else
			return gradients[ ( z*y_points + y ) * x_points +x ];
#endif
		}

		/// The field update function to update the SFOctTree field.
		virtual void update();

		void createSurfaceMesh(OctTreeNode *tree);

	protected:

		/// Finds the approximate point of intersection of the surface
		/// between two points with the values fValue1 and fValue2
		float fGetOffset(float fValue1, float fValue2, float fValueDesired);

		/// Stores the last iso_value.
		H3DFloat old_value;

		/// The volume data. Each value is a value between 0 and 1. Dimensions of
		/// the data can be found in x_points, y_points and z_points,
		float *data_matrix;

		/// data before it was smoothed
		float *unsmoothedDataMatrix;

		/// texture data
		float *textureMatrix;
		uint texSizeX, texSizeY, texSizeZ;

		/// highlight data
		uint *hilightMatrix;
		uint hilightSizeX, hilightSizeY, hilightSizeZ;
		vector<RGB> hilightColours;
		RGB defaultHilightColour;

		/// colour data
		RGB *cryoColourMatrix;
		uint cryoColoursizeX, cryoColoursizeY, cryoColoursizeZ;

		/// The size in metres of each voxel of the data in data_matrix.
		Vec3f voxel_size;

		/// The x-dimension of the data in data_matrix.
		uint x_points;
		/// The y-dimension of the data in data_matrix.
		uint y_points;
		/// The z-dimension of the data in data_matrix.
		uint z_points;

		DataBounds dataBounds;

		/// The gradients in each point in data_matrix
		/// ( when calculated by grad() )
		vector<Vec3f> gradients;

		/// the number of functions currently executing updates in separate
		/// threads.
		uint function_count;

		/// Callback function for calculating new triangles in separate threads.
		static PeriodicThread::CallbackCode calculateNewTriangles(void * data);

		/// Callback function for transfering triangle updates after done in
		/// separate thread.
		static Scene::CallbackCode transferUpdatedTriangles(void *data);

		// thread used for updating the marching cubes triangles.
		auto_ptr<PeriodicThread> update_thread;

	}; //end of  class SFOctTree

    typedef DependentSFNode<X3DTexture3DNode, 
                            FieldRef<H3DDisplayListObject,
                            	H3DDisplayListObject::DisplayList,
                            	&H3D::H3DDisplayListObject::displayList>, 
                            true > SFTexture3DNode;


	typedef DependentSFNode<MaterialSegmentationModel,
                                FieldRef<H3DDisplayListObject,
                                	H3DDisplayListObject::DisplayList,
                                	&H3D::H3DDisplayListObject::displayList>,
                                true > SFMaterialSegmentationNode;

	typedef DependentSFNode<SmoothingMask,
								FieldRef<H3DDisplayListObject,
									H3DDisplayListObject::DisplayList,
									&H3D::H3DDisplayListObject::displayList>,
								true > SFSmoothingMask;

	/// The SFMaterialNode field is dependent on the displayList field
	/// of the containing X3DMaterialNode.
	typedef DependentSFNode< Material, 
							 FieldRef< H3DDisplayListObject,
									   H3DDisplayListObject::DisplayList,
									   &H3DDisplayListObject::displayList >, 
							 true > SFMaterialNode;

	class SFIso: public TypedField<SFFloat,
			Types<SFFloat, SFFloat, SFMaterialSegmentationNode, SFInt32,
					SFInt32, SFInt32> > {
	public:
		virtual void update();
	};

	/// The SFBound class is specialized to update its Bound from the 
	/// voxel data routed to it.
	///
	/// routes_in[0] is the voxels (SFTexture3DNode)
    class SFBound: public TypedField< X3DGeometryNode::SFBound,
                   SFTexture3DNode > {
		virtual void update();
	};

	/// Constructor.
	MCWithRange(Inst<SFNode> _metadata = 0, 
				Inst<SFBound> _bound = 0,
				Inst<DisplayList> _displayList = 0, 
				Inst<SFIso> _isovalue = 0,
				Inst<SFOctTree> _octTree = 0, 
				Inst<SFTexture3DNode> _voxels = 0,
				Inst<SFFloat> _isoStart = 0, 
				Inst<SFFloat> _isoEnd = 0,
				Inst<SFInt32> _segNo = 0, 
				Inst<SFInt32> _segStart = 0,
				Inst<SFInt32> _segEnd = 0,
				Inst<SFMaterialSegmentationNode> _segmentModel = 0,
				Inst<SFSmoothingMask> _smoothingMask = 0,
				Inst<SFTexture3DNode> _texture3D = 0,
				Inst<SFMaterialNode> _material = 0, 
				Inst<SFTexture3DNode> _hilight = 0, 
				Inst<SFTexture3DNode> _cryoColours = 0,
				Inst<SFBool> _generateSurface = 0, 
				Inst<MFVec3f> _surfaceMesh = 0,
				Inst<MFVec3f> _surfaceNormals = 0, 
				Inst<SFBool> _toggleHilight = 0,
				Inst<MFColor> _hilightColours = 0,
				Inst<SFBool> _sequentialHilightMode = 0,
				Inst<SFInt32> _currentHilightSegment = 0);

	/// Render the node in OpenGL.
	virtual void render();

	/// Return the range start
	float getRangeStart() {
		return rangeStart;
	}

	/// Set the range start
	void setRangeStart(float _rangeStart) {
		rangeStart = _rangeStart;
	}

	/// Return the range end
	float getRangeEnd() {
		return rangeEnd;
	}

	/// Set the range end
	void setRangeEnd(float _rangeEnd) {
		rangeEnd = _rangeEnd;
	}

	/// Return the isoMid value
	float getIsoMid() {
		return isoMid;
	}

	/// Set the isoMid value
	void setIsoMid(float _isoMid) {
		isoMid = _isoMid;
	}

	/// Return the maximum value of segments
	float getMaxSegmentDataVal() {
		return maxSegmentDataVal;
	}

	/// Set the maximum value of segments
	void setMaxSegmentDataVal(float _maxSegmentDataVal) {
		maxSegmentDataVal = _maxSegmentDataVal;
	}

	/// The iso-value of the iso-surface for which we should extract triangles.
	/// 
	/// <b>Access type:</b> inputOutput \n
	/// <b>Default value:</b> 10
	auto_ptr<SFFloat> isovalue;

	/// The internal octTree structure used for dynamic updates of the iso
	/// surface.
	auto_ptr<SFOctTree> octTree;

	/// The voxel data to extract iso surfaces in.
	///
	/// <b>Access type:</b> inputOutput
	auto_ptr<SFTexture3DNode> voxels;

	/// Start of the iso range for rendering (inclusive). Should be accompanied with a matching isoEnd or segEnd value.
	/// if not, the end of the last segment is used as isoEnd. isoStart should be a fraction of the maximum data value.
	auto_ptr<SFFloat> isoStart;

	/// End of the iso range for rendering (inclusive). Should be accompanied with a matching isoStart or segStart value.
	/// if not, the start of the first segment (one after the air segment) is used as isoStart. isoEnd should be a fraction
	/// of the maximum data value. Note that the segment isoEnd belongs to will be treated as valid data. Therefore, if
	/// it is close to the start of a segment, data in that segment will be used to calculate the surface intersections.
	/// To avoid this, in such instances, it is best to use segEnd instead.
	auto_ptr<SFFloat> isoEnd;

	/// Specifies the segment to be rendered. If this is given, the other fields (isoStart, isoEnd, segStart, segEnd) will be
	/// ignored.
	auto_ptr<SFInt32> segNo;

	/// The first segment in a sequence to be rendered. Should be accompanied by an isoEnd or segEnd field. If not, the
	/// end of the last segment will be used as the end value.
	auto_ptr<SFInt32> segStart;

	/// The last segment in a sequence to be rendered. Should be accompanied by an isoStart or segStart field. If not, the
	/// start of the first segment will be used as the start value.
	auto_ptr<SFInt32> segEnd;

	/// Material Segmentation Model
	auto_ptr<SFMaterialSegmentationNode> materialSegmentationModel;

	/// Smoothing mask to be used in realtime smoothing of the rendered surface.
	auto_ptr<SFSmoothingMask> smoothingMask;

	/// Textue node that defines the intensity of a voxel
	auto_ptr<SFTexture3DNode> texture3D;

	/// The material field, if specified, shall contain a Material node. If
	/// the material field is NULL or unspecified, lighting is off (all lights
	/// are ignored during rendering of the object that references this
	/// Appearance) and the unlit object colour is (1, 1, 1). 
	auto_ptr<SFMaterialNode> material;

	/// Node that defines the areas to be hilighted. Goes together with hilightColours 
	auto_ptr<SFTexture3DNode> hilight;

	/// Colours (RGBA values between 0 and 1) for the unique values in hilight. These colours will be 
	/// assigned sequentially to values present in hilight (in ascending order). If there are more values 
	/// in hilight than defined here, the last colour will be used for the remainder
	auto_ptr<MFColor> hilightColours;

	// Boolean that turns hilighting on and off 
	auto_ptr<SFBool> toggleHilight;

	// Boolean that denotes if the sequential hilight mode should be turned on. The default is off - all 
	// hilight segments will be shown in the colours given in hilightColours. If this mode is turned on, 
	// initially, it will only show the first segment. Once a defined percentage of the first segment has  
	// been drilled, the second will be shown. This is designed to guide the user step-by-step through the  
	// procedure. The hilight segment nrrd should be sent to the VolumeModel to ensure that updates are    
	// sent when hilight voxels are drilled away. Also, currentHilightSegment vector should be routed from 
	// the VolumeModel to enable this update
	auto_ptr<SFBool> sequentialHilightMode;

	// current hilight segment that's being drilled
	auto_ptr<SFInt32> currentHilightSegment;

	// Node that gives the colour information for each voxel. If present, will override the colours in material node
	auto_ptr<SFTexture3DNode> cryoColours;

	/// Boolean value when true generates the surface mesh and corresponding normals
	auto_ptr<SFBool> generateSurface;

	/// Coordinates of the triangles that form the surface mesh
	auto_ptr<MFVec3f> surfaceMesh;

	/// Normals of the triangles that form the surface mesh at vertices
	auto_ptr<MFVec3f> surfaceNormals;

	/// The H3DNodeDatabase for this node.
	static H3DNodeDatabase database;

protected:
	/// a2iVertexOffset lists the positions (int), relative to vertex0,
	/// of each of the 8 vertices of a cube
	static const int a2iVertexOffset[8][3];

	/// a2fVertexOffset lists the positions (float), relative to vertex0,
	/// of each of the 8 vertices of a cube
	static const float a2fVertexOffset[8][3];

	/// a2iEdgeConnection lists the index of the endpoint vertices for each of
	/// the 12 edges of the cube
	static const int a2iEdgeConnection[12][2];

	/// a2fEdgeDirection lists the direction vector (vertex1-vertex0) for each
	/// edge in the cube
	static const float a2fEdgeDirection[12][3];

	/// For each of the possible vertex states listed in aiCubeEdgeFlags
	/// there is a specific triangulation of the edge intersection points.
	/// a2iTriangleConnectionTable lists all of them in the form of
	/// 0-5 edge triples with the list terminated by the invalid value -1.
	/// For example: a2iTriangleConnectionTable[3] list the 2 triangles 
	/// formed when corner[0] and corner[1] are inside of the surface, but
	/// the rest of the cube is not.
	static const int a2iTriangleConnectionTable[256][16];

	/// For any edge, if one vertex is inside of the surface and the other
	/// is outside of the surface then the edge intersects the surface.
	/// For each of the 8 vertices of the cube can be two possible states :
	/// either inside or outside of the surface.
	/// For any cube the are 2^8=256 possible sets of vertex states.
	/// This table lists the edges intersected by the surface for all 256
	/// possible vertex states. There are 12 edges. For each entry in the 
	/// table, if edge bit n is intersected, then bit n is set to 1
	static const int aiCubeEdgeFlags[256];

	/// Start of the range for rendering. Values outside of this range will be set to 0.
	float rangeStart;

	/// End of the range for rendering. Values outside of this range will be set to 0.
	float rangeEnd;

	/// The value around which the data is folded if an iso range is given.
	float isoMid;

	/// The maximum data value in the segmentation model.
	float maxSegmentDataVal;

  };
}

#endif
